useState가 리액트 엔진에게 요청을 한다 : 재랜더링 ( 리렌더링)


배열이 초기값으로 들어 있어요 
비어있는 문자열이 들어있어요 

const [names, setNames] = useState(['정수아', '리액트']);
names에 배열, ['정수아', '리액트'] 가 들어 있음.

const [input, setInput = useState(''); 
input에 빈값이 들어 있음.

배열을 가지고 map함수를 돌려봐라 
names.map((name, idx) => (<p key ={idx}>{name}</p>))}
하나씩 빼서 name이라는 것에 담으래 
p 태그로 
정수아, 리액트 나오게 됨 




인풋창 안에 있는, 실제 눈에 보이는 value 
uploadInput 




setNames([input])
input을 배열로 넣어서 setNames를 변경하세요



useState가 리액트 엔진에게 render()함수 자동 실행시켜줘 요청하게 되면
리액트 엔진이 render()해줌, (새로고침 시켜줌.)


useEffect
매개변수로 콜백함수 
ㄴ처음 랜더링 되었을 때만 데이터를 가져왔으면 좋겠어!

useEffect(() =>{콜백함수, 배열})
useEffect(()=>{//작업},[value])

🔵
useEffect()
매개변수1 : 콜백함수  - 필수사항 
매개변수2 : 배열   -    옵션
=======================
매개변수 1 : 콜백함수 
- 렌더링 될 때마다 콜백함수가 실행 
- 네트워크 통신 -> 데이터를 가져오기 
- 사용하는 의미가 없다.

🔵
매개변수1 : 콜백함수
매개변수2 : 배열 -> []
비어있는 배열이 있다.
 최초에 한 번만 작업을 수행한다.

🔵
매개변수1 : 콜백함수
매개변수2 : 배열 -> [변수이름]
-변수의 값이 


Useref 와 UseState의 차이점 
값의 렌더링의 차이점 
값이 변경이 되면 화면도 다시 그리는 것 : UseState
값이 변경이 되어도 화면갱신에는 상관이 없는 것 : UseRef 

UseRef 
일반 변수 
일반 변수는 렌더링이 되는 순간에 다시 초기값인 0으로 되어 버림 .

일반변수와 Ref 변수의 차이점



리액트에서 변수 만드는 방법 3가지 
usestate
useref 
일반 변수 


usesate : 값이 바뀌면 화면을 다시 그리는 것 
useref : 값이 아무리 바뀌어도 화면을 다시 랜더링 하지 않는 거 
일반 변수 : ???   화면이 렌더링 되는 순간에 화면이 로기값으로 바뀌는 것 . 


ㄴ 정확하지 않을 수 있음 다시 찾아서 정리하기 


useRef : 특정 DOM 요소에 접근 
DOM : HTML 태그에 





컴포넌트 내부에서 자주 값이 바뀌는 값이 있고, 화면 출력에는 영향을 미치지 않는 것에 UseRef 를 사용하면 성능에 좋아진다.

화면 렌더 하는 게 컴퓨터 입장에서 좋은 일은 아니다

빈배열 : 최초의 한 번만 실행

렌더링 : 페이지 새로고침 


----------------------------------------------------------------------------------------------------------------------

map 배열의 내장 함수 
값을 넣으면 사라지죠 
값을 넣은 값을 가진게 value 
value 가 value

이걸이제 버튼 이벤트로 가지고 와야 함 

